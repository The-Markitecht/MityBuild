#!/usr/bin/env tclsh

source [file join [pwd] [file dirname [info script]] libMityBuild]

proc assert {exp {msg {}}} {
    tracer asserts "testing: $exp"
    if {$msg eq {}} {set msg "assert failed: $exp"}
    set result [uplevel 1 "expr {$exp}"]
    if $result {} else {error $msg}
}

set testRecipes {
    # these recipes are wrapped in a big brace block for testing purposes.  that's not normal.

    recipe final {} {} run {}

    recipe toolsClang {} {
        # Clang toolchain settings for all recipes.  for clang with their libc++.
        # see recipe toolsCcDefault for explanations.
        export cc clang++  ;# Clang for the PC host's operating system.
        export ld $cc  ;# use same tool again for linking.
        export commonOptions [list -pipe -O$optim -g3 -Wall -fmessage-length=0 -fPIC]
        export sourceDependencyOptions [list -MMD -MT sources] ;# causes dumping source file dependency list into .d file.
        export cLanguageOptions [list {*}$commonOptions -c -xc++ -std=c++14 -stdlib=libc++ {*}$sourceDependencyOptions]
        export asmLanguageOptions [list {*}$commonOptions -c -xassembler-with-cpp {*}$sourceDependencyOptions]
        export linkerOptions [list {*}$commonOptions -std=c++14 -stdlib=libc++ -pthread]
        export libOptions [list -fpic -shared] ;# -rdynamic
    } run {}

    recipe emptyBuild {} {} run {}

    recipe testFileTree {} {} run {
        export testRoot [tempFilename]
        file mkdir $testRoot
        cd $testRoot
        file mkdir a
        cd a
        file mkdir b
        cd b
        file mkdir c
        file copy [file join $::builderDir libMityBuild] c
        file mkdir d
        file copy [file join $::builderDir libMityBuild] d
        cd d
        file mkdir e
        file copy [file join $::builderDir libMityBuild] e
    }        

    recipe settings5 {} {} run {}
    
    recipe test5 {} {} run {
        # shorthand assignments with literals.
        a = 5
        assert {$a == 5}
        a := 5 * 10
        assert {$a == 50}
        # allow literal equal signs also.
        set s [list = 2]
        assert {$s == {= 2}}
        set s [list := 2]
        assert {$s == {:= 2}}
        # shorthand indexing with literals.
        people = [dict create mark 40 julie 45 kids [dict create aiden 9 andrea 8]]
        assert {[people@mark] == 40}
        assert {[people@kids@andrea] == 8}
        assert {[people@kids@jackie 3] == 3}
        lt = {zero one two three four}
        assert {[lt#1] eq {one}}
        assert {[lt#1#end-1] eq {one two three}}
        # variables in expressions.
        i := $a / 5
        assert {$i == 10}
        i := $a/5
        assert {$i == 10}
        # variables in indices.
        kid = aiden
        assert {[people@kids@$kid] == 9}
        i = 3
        assert {[lt#end-$i] == {one}}
        # shorthand dict set.
        people@bob = 48
        assert {[dict get $people bob] == 48}
        people@kids@sheldon = 10
        assert {[dict get $people kids sheldon] == 10}
        people@kids@leonard := [people@kids@sheldon] + 2
        assert {[dict get $people kids leonard] == 12}
        # ... with variable indices.
        name = siri
        people@$name = 30
        assert {[people@siri] == 30}
        people@$name := [people@$name] + 2
        assert {[people@siri] == 32}
        # variable dict name and indices combined.
        name = people@kids@leonard
        assert {[$name] == 12}
        $name = 14
        assert {[$name] == 14}
        $name := [$name] + 2
        assert {[$name] == 16}
    }

    recipe settings18 {} {} run {}

    recipe test18 {} {} run {
        set fn {/media/android/Internal shared storage/Android/data/com.amazon.kindle/files/appexpan/nlnAssets_high_res/1/land/nln_brochure_card_2.jpg}
        set dest [remainder $fn {/media/android}]
        tracer tests "dest $dest"
        assert {$dest eq {Internal shared storage/Android/data/com.amazon.kindle/files/appexpan/nlnAssets_high_res/1/land/nln_brochure_card_2.jpg}}
    }

    recipe settings20 {} {} run {}

    recipe test20 {} {} run {
        require top
        assert {{paths} ni [info vars]}
    }

    recipe top {} {} run {
        set topvar isTop
        array set a {5 five}
        require second
        assert {$paths eq [list p1 p2]}
        require topsibling
    }

    recipe second {} {} run {
        assert {$topvar eq {isTop}}
        export paths [list p1]
        assert {$paths eq [list p1]}
        require third
        require sibling
        tracer tests "second paths $paths"
    }

    recipe third {} {} run {
        assert {$paths eq [list p1]}
        require fourth
        assert {$paths eq [list p1 p2]}
    }

    recipe fourth {} {} run {
        assert {$paths eq [list p1]}
        export+ paths p2
        assert {$paths eq [list p1 p2]}
    }

    recipe sibling {} {} run {
        assert {$paths eq [list p1 p2]}
    }

    recipe topsibling {} {} run {
        assert {$paths eq [list p1 p2]}
    }

    recipe settings25 {} {} run {}

    recipe test25 {} {} run {
        require testFileTree
        recurseDepthFirst $testRoot lib* [notHiddenPattern]  {
            x ls -l $fn
        }
        recurseBreadthFirst $testRoot lib* [notHiddenPattern]  {
            x ls -l $fn
        }
    }
    
    recipe settings30 {} {} run {}

    recipe test30 {} {} run {
        require testFileTree
        set myFiles [list]
        recurseDepthFirst $testRoot lib* [notHiddenPattern]  {
            # reversing order; this tests list manipulation on exported vars.
            export myFiles [linsert $myFiles 0 $fn]
        }
        tracer tests recurse:[llength $myFiles]:$myFiles
        assert {[llength $myFiles] == 3}
        assert {[lindex $myFiles 0] == [file join $testRoot a b d libMityBuild]}
    }

    recipe settings40 {} {} run {}

    recipe test40 {} {} run {
        require testFileTree
        cd $testRoot
        set f [open main.cpp w]
        puts $f {
            #include <iostream>
            int main(int argc, char* argv[]) {
                std::cout << "hello" << std::endl;
            }
        }
        close $f
        require toolsClang
        require compileAndLink testProgram linkExecutable $testRoot \
            [findFiles {*.cpp *.CPP} [notHiddenPattern] $testRoot] 
        assert {[file exists testProgram]}
        set output [x ./testProgram 2>@stderr <@stdin]
        assert {[string trim $output] eq {hello}}
    }

    recipe settings50 {} {} run {}

    recipe test50 {} {} run {
        # testing findFiles to verify it works.
        require testFileTree
        set allFns myOldFileList 
        set all [findFiles lib* [notHiddenPattern] $testRoot]
        tracer tests "found: $all"
        assert {[llength $all] == 3}    
        assert {$all eq [list  \
            [file join $testRoot a b c libMityBuild]  \
            [file join $testRoot a b d libMityBuild]  \
            [file join $testRoot a b d e libMityBuild]  \
        ]}
        # also testing whether findFiles leaks an export of allFns.
        assert {$allFns eq {myOldFileList}}
    }

    recipe settings60 {} {
        require tools Clang
    } run {}

    recipe test60 {} {} run {
        assert {$cc eq {clang++}}
        require foreignLibraryTest
        assert {$cc eq {clang++}}
    }
    
    recipe foreignLibraryTest {} {} run {
        trapExports $toolVars
        assert {$cc eq {clang++}}
        require toolsForeign
        assert {$cc eq {special-gcc}}
        require compileForeign
    }
    
    recipe toolsForeign {} {
        export cc special-gcc
        assert {$cc eq {special-gcc}}
    } run {}
    
    recipe compileForeign {} {} run {
        assert {$cc eq {special-gcc}}
    }
}

puts stderr ===============================================
set i [lsearch -exact $::argv debug]
if {$i >= 0} {set debugNames [lindex $::argv ${i}+1]}
eval $testRecipes
for {set i 1} {$i < 1000} {incr i} {
    if [dict exists $::recipes test$i] {
        # re-initialize the builder library before each test.
        source [file join $::builderDir libMityBuild]
        # define a batch of recipes required for this test.
        eval $testRecipes
        # artificially set command-line parameters.
        set ::argv [list {trace tests asserts builderStack commands} test$i]
        # execute the build, and trace the progress.
        tracer tests "running test$i"
        if [info exists debugNames] {startDebug $debugNames}
        runMityBuild settings$i final CcDefault
        tracer tests "passed test$i"
    }
}

